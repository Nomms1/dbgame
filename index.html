<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Goku Runner - Dragon Ball Dino Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(to bottom, #4a90e2, #e0f6ff);
      font-family: 'Arial Black', Arial, sans-serif;
      color: #333;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      border: 4px solid #333;
      border-radius: 8px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      background: #f7f7f7;
      cursor: pointer;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      width: 800px;
      margin-bottom: 10px;
      font-size: 24px;
      font-weight: bold;
      color: #ff6b35;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    .form-display {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      color: #ffd700;
      text-shadow: 1px 1px 2px #000;
      font-weight: bold;
    }
    @media (max-width: 850px) {
      .hud {
        width: 100%;
        max-width: 800px;
        padding: 0 20px;
        box-sizing: border-box;
      }
      canvas {
        max-width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div class="hud">
      <div id="score">0</div>
      <div>HI <span id="hiScore">0</span></div>
    </div>
    <div class="form-display" id="form">Base Goku</div>
    <canvas id="canvas" width="800" height="200"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const hiScoreEl = document.getElementById('hiScore');
    const formEl = document.getElementById('form');

    const GROUND_Y = 160;

    const forms = [
      {name: "Base Goku", color: "#2a2a2a", spikes: 4, len: 12, longHair: false, aura: false},
      {name: "Super Saiyan", color: "#ffd700", spikes: 7, len: 22, longHair: false, aura: true},
      {name: "Super Saiyan 2", color: "#ffd700", spikes: 7, len: 22, longHair: false, aura: true, lightning: true},
      {name: "Super Saiyan 3", color: "#ffd700", spikes: 11, len: 35, longHair: true, aura: true},
      {name: "Super Saiyan God", color: "#dc143c", spikes: 5, len: 18, longHair: false, aura: true},
      {name: "Super Saiyan Blue", color: "#4169e1", spikes: 7, len: 22, longHair: false, aura: true},
      {name: "Ultra Instinct", color: "#c0c0c0", spikes: 4, len: 15, longHair: false, aura: true, uiEyes: true}
    ];

    function getCurrentForm(score) {
      if (score < 500) return 0;
      if (score < 1000) return 1;
      if (score < 1600) return 2;
      if (score < 2600) return 3;
      if (score < 3600) return 4;
      if (score < 5000) return 5;
      return 6;
    }

    let frame = 0;
    let score = 0;
    let hiScore = parseInt(localStorage.getItem('gokuHiScore') || '0');
    hiScoreEl.innerText = hiScore;
    let currentDistance = 0;
    let speed = 6;
    let speedUps = 0;
    let gameStarted = false;
    let gameOver = false;
    let currentFormIdx = 0;
    let obTimer = 0;
    let obGap = 150;
    let groundOffset = 0;
    let clouds = [];
    let obstacles = [];
    let player = {
      x: 50,
      y: GROUND_Y,
      vy: 0,
      jumping: false,
      ducking: false,
      animFrame: 0
    };
    let keys = {};

    // Initial clouds for start screen
    for (let i = 0; i < 3; i++) {
      clouds.push({
        x: 120 + i * 280,
        y: 35 + Math.random() * 30,
        size: 18 + Math.random() * 16
      });
    }

    function collide(a, b) {
      return a.x < b.x + b.width &&
             a.x + a.width > b.x &&
             a.y < b.y + b.height &&
             a.y + a.height > b.y;
    }

    function addCloud() {
      clouds.push({
        x: canvas.width,
        y: 25 + Math.random() * 45,
        size: 16 + Math.random() * 20
      });
    }

    function drawCloud(c) {
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.size, 0, 2 * Math.PI);
      ctx.arc(c.x + c.size * 0.6, c.y - c.size * 0.3, c.size * 0.8, 0, 2 * Math.PI);
      ctx.arc(c.x + c.size * 1.2, c.y, c.size * 0.7, 0, 2 * Math.PI);
      ctx.arc(c.x + c.size * 0.3, c.y + c.size * 0.2, c.size * 0.9, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawObstacle(ob) {
      if (ob.type === 'ground') {
        // Rock obstacle
        ctx.fillStyle = '#6d4c41';
        ctx.beginPath();
        ctx.roundRect(ob.x, ob.y, ob.width, ob.height, 6);
        ctx.fill();
        ctx.fillStyle = '#8d6e63';
        ctx.beginPath();
        ctx.roundRect(ob.x + 3, ob.y + 5, ob.width - 6, ob.height - 10, 4);
        ctx.fill();
        // Top spike
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.moveTo(ob.x + ob.width / 2, ob.y);
        ctx.lineTo(ob.x + ob.width / 2 - 8, ob.y - 12);
        ctx.lineTo(ob.x + ob.width / 2 + 8, ob.y - 12);
        ctx.closePath();
        ctx.fill();
        // Crack
        ctx.strokeStyle = '#4e342e';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(ob.x + 6, ob.y + 12);
        ctx.lineTo(ob.x + 6, ob.y + ob.height - 8);
        ctx.lineTo(ob.x + ob.width - 10, ob.y + ob.height - 12);
        ctx.stroke();
      } else {
        // Flying ki blast
        const cx = ob.x + 20;
        const cy = ob.y + 12.5;
        // Animated trail
        for (let i = 0; i < 5; i++) {
          const alpha = 0.6 - i * 0.12;
          ctx.fillStyle = `rgba(255, 105, 180, ${alpha})`;
          const trailX = cx - (i + 1) * 9;
          const trailY = cy + Math.sin((frame + i * 8) * 0.15) * 3;
          ctx.beginPath();
          ctx.ellipse(trailX, trailY, 5 + i * 2.5, 4 + i * 1.8, 0, 0, 2 * Math.PI);
          ctx.fill();
        }
        // Pulsing core
        const pulse = 1 + Math.sin(frame * 0.25) * 0.15;
        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(pulse, pulse * 0.8);
        ctx.fillStyle = '#ff69b4';
        ctx.beginPath();
        ctx.arc(0, 0, 12, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = '#ffb6c1';
        ctx.beginPath();
        ctx.arc(0, 0, 17, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawPlayer() {
      const formIdx = getCurrentForm(score);
      const form = forms[formIdx];
      const isDucking = player.ducking && !player.jumping;
      const pHeight = isDucking ? 32 : 52;
      const headY = player.y - pHeight + 2;
      const bodyTop = player.y - pHeight + 12;
      const bodyH = isDucking ? 16 : 26;

      // Aura
      if (form.aura) {
        const auraPulse = 1.1 + Math.sin(frame * 0.12) * 0.25;
        ctx.save();
        ctx.translate(player.x, headY - 8);
        ctx.scale(auraPulse, auraPulse * 0.65);
        ctx.fillStyle = form.color + '44';
        ctx.beginPath();
        ctx.ellipse(0, 0, 30, 42, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
      }

      // Legs with animation
      ctx.fillStyle = '#1e40af';
      const legTop = player.y - 24;
      let leftKnee = 0;
      let rightKnee = 0;
      if (!player.jumping && !isDucking) {
        const phase = player.animFrame * 0.3;
        leftKnee = Math.sin(phase) * 7;
        rightKnee = Math.sin(phase + Math.PI) * 7;
      }
      // Left leg
      ctx.fillRect(player.x - 9, legTop, 7, 12);
      ctx.fillRect(player.x - 11, legTop + 12 + leftKnee, 7, 12);
      // Right leg
      ctx.fillRect(player.x + 2, legTop, 7, 12);
      ctx.fillRect(player.x + 4, legTop + 12 + rightKnee, 7, 12);

      // Gi body
      ctx.fillStyle = '#ff8c00';
      ctx.fillRect(player.x - 13, bodyTop, 26, bodyH);
      // Undershirt
      ctx.fillStyle = '#000080';
      ctx.fillRect(player.x - 11, bodyTop + 4, 22, bodyH - 8);
      // Belt
      ctx.fillStyle = '#a67c52';
      ctx.fillRect(player.x - 13, bodyTop + bodyH - 4, 26, 4);

      // Arms
      ctx.fillStyle = '#ffdbac';
      const armTop = bodyTop + 2;
      const armLen = isDucking ? 10 : 18;
      ctx.fillRect(player.x - 18, armTop, 8, armLen);
      ctx.fillRect(player.x + 10, armTop, 8, armLen);

      // Head
      ctx.fillStyle = '#ffdbac';
      ctx.beginPath();
      ctx.arc(player.x, headY, 13, 0, 2 * Math.PI);
      ctx.fill();

      // Hair
      ctx.fillStyle = form.color;
      // Bangs
      ctx.beginPath();
      ctx.moveTo(player.x - 10, headY + 4);
      ctx.quadraticCurveTo(player.x, headY + 9, player.x + 10, headY + 4);
      ctx.quadraticCurveTo(player.x + 5, headY + 7, player.x - 5, headY + 7);
      ctx.fill();
      // Spikes
      const spacing = form.longHair ? 3.2 : 5.5;
      for (let i = 0; i < form.spikes; i++) {
        const sx = player.x + (i - form.spikes / 2 + 0.5) * spacing;
        const sy = headY - 3;
        const sl = form.len;
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx - 2.5, sy - sl);
        ctx.lineTo(sx + 2.5, sy - sl);
        ctx.closePath();
        ctx.fill();
      }

      // Eyes
      if (form.uiEyes) {
        ctx.fillStyle = '#f5f5f5';
        ctx.beginPath();
        ctx.arc(player.x - 5, headY - 2, 4, 0, 2 * Math.PI);
        ctx.arc(player.x + 5, headY - 2, 4, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillStyle = '#a8a8a8';
        ctx.beginPath();
        ctx.arc(player.x - 5, headY - 2, 1.8, 0, 2 * Math.PI);
        ctx.arc(player.x + 5, headY - 2, 1.8, 0, 2 * Math.PI);
        ctx.fill();
      } else {
        ctx.fillStyle = '#000';
        ctx.fillRect(player.x - 7, headY - 5, 5, 4);
        ctx.fillRect(player.x + 2, headY - 5, 5, 4);
      }

      // Mouth
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(player.x, headY + 6, 4, 0, Math.PI);
      ctx.fill();

      // Lightning for SSJ2
      if (form.lightning) {
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        const lPhase = frame * 0.4;
        // Left bolt
        ctx.beginPath();
        ctx.moveTo(player.x - 10, headY + 12);
        ctx.lineTo(player.x - 18 + Math.sin(lPhase) * 3, headY + 4);
        ctx.lineTo(player.x - 22, headY - 6);
        ctx.lineTo(player.x - 28 + Math.cos(lPhase) * 4, headY - 2);
        ctx.stroke();
        // Right bolt
        ctx.beginPath();
        ctx.moveTo(player.x + 12, headY + 10);
        ctx.lineTo(player.x + 20 + Math.sin(lPhase + 1) * 3, headY + 0);
        ctx.lineTo(player.x + 14, headY - 8);
        ctx.lineTo(player.x + 24 + Math.cos(lPhase + 2) * 4, headY - 4);
        ctx.stroke();
        // Body bolt
        ctx.beginPath();
        ctx.moveTo(player.x + 3, bodyTop + 8);
        ctx.lineTo(player.x + 12 + Math.sin(lPhase + 3) * 4, bodyTop - 4);
        ctx.lineTo(player.x + 6, bodyTop + 2);
        ctx.stroke();
      }
    }

    function restart() {
      obstacles = [];
      clouds = [];
      player.x = 50;
      player.y = GROUND_Y;
      player.vy = 0;
      player.jumping = false;
      player.ducking = false;
      player.animFrame = 0;
      score = 0;
      currentDistance = 0;
      speed = 6;
      speedUps = 0;
      currentFormIdx = 0;
      obTimer = 0;
      obGap = 150;
      groundOffset = 0;
      gameOver = false;
      scoreEl.innerText = '0';
      formEl.innerText = forms[0].name;
      // Initial clouds
      for (let i = 0; i < 4; i++) {
        clouds.push({
          x: 100 + i * 220,
          y: 30 + Math.random() * 35,
          size: 18 + Math.random() * 15
        });
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
      skyGrad.addColorStop(0, '#4a90e2');
      skyGrad.addColorStop(0.6, '#87ceeb');
      skyGrad.addColorStop(1, '#d4f1ff');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, canvas.width, GROUND_Y);

      // Clouds
      clouds.forEach(drawCloud);

      // Obstacles
      obstacles.forEach(drawObstacle);

      // Ground
      ctx.fillStyle = '#f0e8d8';
      ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

      // Ground lines
      ctx.strokeStyle = '#d4af37';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      for (let x = groundOffset - 40; x < canvas.width + 40; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, GROUND_Y - 2);
        ctx.lineTo(x + 20, GROUND_Y - 2);
        ctx.stroke();
      }

      // Player
      drawPlayer();

      // Overlays
      if (!gameStarted) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.65)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ffd700';
        ctx.font = 'bold 50px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GOKU RUNNER', canvas.width / 2, canvas.height / 2 - 50);
        ctx.font = 'bold 26px Arial';
        ctx.fillStyle = '#fff';
        ctx.fillText('Dodge rocks & ki blasts to transform!', canvas.width / 2, canvas.height / 2 - 10);
        ctx.font = '20px Arial';
        ctx.fillText('JUMP: SPACE or ↑    DUCK: ↓', canvas.width / 2, canvas.height / 2 + 30);
        ctx.fillText('Get far to go Super Saiyan & beyond!', canvas.width / 2, canvas.height / 2 + 60);
      } else if (gameOver) {
        ctx.fillStyle = 'rgba(51, 51, 51, 0.8)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 52px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 40);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 34px Arial';
        ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 5);
        if (score > hiScore) {
          ctx.fillStyle = '#ffd700';
          ctx.font = 'bold 28px Arial';
          ctx.fillText('NEW HIGH SCORE!', canvas.width / 2, canvas.height / 2 + 45);
        }
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.fillText('SPACEBAR to restart', canvas.width / 2, canvas.height / 2 + 85);
      }
      ctx.textAlign = 'start';
    }

    function gameLoop() {
      frame++;
      player.animFrame++;

      // Input handling for start/restart
      if (!gameStarted && keys[32]) {
        gameStarted = true;
        keys[32] = false;
      }
      if (gameOver && keys[32]) {
        restart();
        keys[32] = false;
      }

      if (gameStarted && !gameOver) {
        // Jump input
        if ((keys[32] || keys[38]) && !player.jumping) {
          player.vy = -14.5;
          player.jumping = true;
          player.ducking = false;
        }
        // Duck input
        player.ducking = keys[40] && !player.jumping;

        // Player physics
        if (player.jumping) {
          player.y += player.vy;
          player.vy += 0.75;
          if (player.y >= GROUND_Y) {
            player.y = GROUND_Y;
            player.vy = 0;
            player.jumping = false;
          }
        }

        // Ground offset
        groundOffset -= speed;
        if (groundOffset < -40) groundOffset += 40;

        // Move obstacles
        obstacles.forEach(o => o.x -= speed);
        obstacles = obstacles.filter(o => o.x + o.width > -20);

        // Move clouds
        clouds.forEach(c => c.x -= speed * 0.4);
        clouds = clouds.filter(c => c.x + c.size * 2 > -20);

        // Add cloud
        if (frame % 160 === 0) {
          addCloud();
        }

        // Add obstacle
        obTimer++;
        if (obTimer >= obGap) {
          obTimer = 0;
          obGap = Math.max(65, 140 - score * 0.015);
          const addX = Math.random() * 25;
          const randType = Math.random();
          if (randType < 0.72) {
            // Ground
            const isDouble = Math.random() < 0.4;
            const h1 = 24 + Math.random() * 32;
            const w1 = 16 + Math.random() * 14;
            obstacles.push({x: canvas.width + addX, y: GROUND_Y - h1, width: w1, height: h1, type: 'ground'});
            if (isDouble) {
              const h2 = 22 + Math.random() * 28;
              const w2 = 15 + Math.random() * 12;
              const gapX = 38 + Math.random() * 35;
              obstacles.push({x: canvas.width + addX + gapX, y: GROUND_Y - h2, width: w2, height: h2, type: 'ground'});
            }
          } else {
            // Air
            obstacles.push({x: canvas.width + addX, y: GROUND_Y - 60, width: 40, height: 25, type: 'air'});
          }
        }

        // Update distance and score
        currentDistance += speed;
        const newScore = Math.floor(currentDistance / 10);
        if (newScore > score) {
          score = newScore;
          scoreEl.innerText = score;
          const newFormIdx = getCurrentForm(score);
          if (newFormIdx > currentFormIdx) {
            currentFormIdx = newFormIdx;
            formEl.innerText = forms[newFormIdx].name;
          }
          // Speed up every 100 points
          if (newScore % 100 === 0) {
            const thisUp = Math.floor(newScore / 100);
            if (thisUp > speedUps) {
              speedUps = thisUp;
              speed += 0.32 + (thisUp * 0.03);
            }
          }
        }

        // Collision detection
        const pHeight = player.ducking ? 32 : 52;
        const pTop = player.y - pHeight;
        const pRect = {x: player.x - 22, y: pTop, width: 44, height: pHeight};
        for (let ob of obstacles) {
          const obRect = {x: ob.x, y: ob.y, width: ob.width, height: ob.height};
          if (collide(pRect, obRect)) {
            gameOver = true;
            if (score > hiScore) {
              hiScore = score;
              hiScoreEl.innerText = hiScore;
              localStorage.setItem('gokuHiScore', hiScore.toString());
            }
            break;
          }
        }
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys[32] = true;
    }, {passive: false});
    canvas.addEventListener('touchend', () => {
      keys[32] = false;
    });

    // Start the game loop
    gameLoop();
  </script>
</body>
</html>
